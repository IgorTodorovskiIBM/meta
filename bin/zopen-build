#!/bin/sh
#asdfasdf
#
# General purpose build script for ZOSOpenTools ports
#
# ZOPEN_BUILD_LINE must be defined to either STABLE or DEV. This indicates the type of package to build
#
# For more details, see the help which you can get by issuing:
# zopen-build -h
#
#
# All zopen-* scripts MUST start with this code to maintain consistency
#
setupMyself() {
	ME=$(basename $0)
	MYDIR="$(cd "$(dirname "$0")" >/dev/null 2>&1 && pwd -P)"
	INCDIR="${MYDIR}/../include"
	if ! [ -d "${INCDIR}" ] && ! [ -f "${INCDIR}/common.sh" ]; then
		echo "Internal Error. Unable to find common.sh file to source" >&2
		exit 8
	fi
	. "${INCDIR}/common.sh"
}
setupMyself

#
# Functions section
#

#
# asciiecho: we are in the process of starting to use 'echo' from coreutils.
# This echo will have a slightly different behaviour than the standard echo in that
# the file will now be tagged as ascii instead of ebcdic
# For compatibility, check the tag of the file after the echo and iconv the file IFF it is IBM-1047
#

asciiecho() {
	text="$1"
	file="$2"

	if ! echo "${text}" >"${file}"; then
		echo "Unable to echo text to ${file}" >&2
		return 2
	fi
	if [ "$(chtag -p "${file}" | cut -f2 -d' ')" = "IBM-1047" ]; then
		if ! /bin/iconv -f IBM-1047 -t ISO8859-1 <"${file}" >"${file}_ascii" || ! chtag -tc ISO8859-1 "${file}_ascii" || ! mv "${file}_ascii" "${file}"; then
			printError "Unable to convert EBCDIC text to ASCII for ${file}" >&2
		fi
	fi
	return 0
}

printEnvVar() {
	echo "
User-Provided environment variables:
  ZOPEN_CC             C compiler (default set by dependency)
  ZOPEN_CXX            C++ compiler (default set by dependency)
  ZOPEN_CPPFLAGS       C/C++ pre-processor flags (default set by dependency)
  ZOPEN_CFLAGS         C compiler flags (default set by dependency)
  ZOPEN_CXXFLAGS       C++ compiler flags (default set by dependency)
  ZOPEN_LDFLAGS        C/C++ linker flags (default set by dependency)
  ZOPEN_LIBS           C/C++ libraries (default set by dependency)
  ZOPEN_TYPE           (Deprecated) The type of package to download. Valid types are TARBALL, BARE and GIT (required)
  ZOPEN_TARBALL_URL    (Deprecated) The fully qualified URL that the tarball should be downloaded from (required if ZOPEN_TYPE=TARBALL)
  ZOPEN_TARBALL_DEPS   (Deprecated) Space-delimited set of source packages this git package depends on to build (required if ZOPEN_TYPE=TARBALL)
  ZOPEN_GIT_URL        (Deprecated) The fully qualified URL that the git repo should be cloned from (required if ZOPEN_TYPE=GIT)
  ZOPEN_GIT_DEPS       (Deprecated) Space-delimited set of source packages this tarball package depends on to build (required if ZOPEN_TYPE=GIT)
  ZOPEN_GIT_BRANCH     (Deprecated) The branch that the git repo should checkout (optional, takes precedence over ZOPEN_GIT_TAG)
  ZOPEN_GIT_TAG        (Deprecated) The tag that the git repo should checkout as a branch (optional)
  ZOPEN_URL            (Deprecated) Alternate environment variable instead of ZOPEN_TARBALL_URL or ZOPEN_GIT_URL (alternate to ZOPEN_TARBALL_URL or ZOPEN_GIT_URL)
  ZOPEN_DEPS           (Deprecated) Alternate environment variable instead of ZOPEN_TARBALL_DEPS or ZOPEN_GIT_DEPS (alternate to ZOPEN_TARBALL_DEPS or ZOPEN_GIT_DEPS)
  ZOPEN_BUILD_LINE     Specify the default build line, either 'DEV' or 'STABLE'
  ZOPEN_DEV_URL        Specify the dev build url (either a git url or tarball url)
  ZOPEN_STABLE_URL     Specify the stable build url (either a git url or tarball url)
  ZOPEN_DEV_DEPS       Specify the dev build dependencies
  ZOPEN_STABLE_DEPS    Specify the stable build dependencies
  ZOPEN_DEV_BRANCH     The branch that the git repo should checkout (optional, takes precedence over ZOPEN_DEV_TAG)
  ZOPEN_DEV_TAG        The tag that the git repo should checkout as a branch (optional)
  ZOPEN_DEV_TYPE       The type of package to download. Valid types are TARBALL, BARE and GIT (optional)
  ZOPEN_STABLE_BRANCH  The branch that the stable repo should checkout (optional, takes precedence over ZOPEN_STABLE_TAG)
  ZOPEN_STABLE_TAG     The tag that the git repo should checkout as a branch (optional)
  ZOPEN_STABLE_TYPE    The type of package to download. Valid types are TARBALL, BARE and GIT (optional)
  ZOPEN_GIT_SETUP      Specify whether git files should be added to a local repo or if this will be done manually (defaults to Y)
  ZOPEN_SRC_DIR        specify a relative source directory to cd to for bootstrap, configure, build, check, install (defaults to '.')
  ZOPEN_EXTRA_CPPFLAGS C/C++ pre-processor flags to append to CPPFLAGS (defaults to '')
  ZOPEN_EXTRA_CFLAGS   C compiler flags to append to CFLAGS (defaults to '')
  ZOPEN_EXTRA_CXXFLAGS C++ compiler flags to append to CXXFLAGS (defaults to '')
  ZOPEN_EXTRA_LDFLAGS  C/C++ linker flags to append to LDFLAGS (defaults to '')
  ZOPEN_EXTRA_LIBS     C/C++ libraries to append to LIBS (defaults to '')
  ZOPEN_NUM_JOBS       Number of jobs that can be run in parallel (defaults to 1/2 the CPUs on the system)
  ZOPEN_BOOTSTRAP      Bootstrap program to run. If skip is specified, no bootstrap step is performed (defaults to '${ZOPEN_BOOTSTRAPD}')
  ZOPEN_BOOTSTRAP_OPTS Options to pass to bootstrap program (defaults to '${ZOPEN_BOOTSTRAP_OPTSD}')
  ZOPEN_CONFIGURE      Configuration program to run. If skip is specified, no configuration step is performed (defaults to '${ZOPEN_CONFIGURED}')
  ZOPEN_CONFIGURE_MINIMAL Configuration program will not be passed CFLAGS, LDFLAGS, CPPFLAGS options but will just get them from env vars
  ZOPEN_CONFIGURE_OPTS Options to pass to configuration program (defaults to '--prefix=\${ZOPEN_INSTALL_DIR}')
  ZOPEN_EXTRA_CONFIGURE_OPTS Extra configure options to pass to configuration program (defaults to '')
  ZOPEN_INSTALL_DIR    Installation directory to pass to configuration (defaults to '\${ZOPEN_PKGINSTALL}/<pkg>/<pkg>')
  ZOPEN_MAKE           Build program to run. If skip is specified, no build step is performed (defaults to '${ZOPEN_MAKED}')
  ZOPEN_MAKE_MINIMAL   Build program will not be passed CFLAGS, LDFLAGS, CPPFLAGS options but will just get them from env vars
  ZOPEN_MAKE_OPTS      Options to pass to build program (defaults to '-j\${ZOPEN_NUM_JOBS}')
  ZOPEN_CHECK          Check program to run. If skip is specified, no check step is performed (defaults to '${ZOPEN_CHECKD}')
  ZOPEN_CHECK_MINIMAL  Check program will not be passed CFLAGS, LDFLAGS, CPPFLAGS options but will just get them from env vars
  ZOPEN_CHECK_OPTS     Options to pass to check program (defaults to '${ZOPEN_CHECK_OPTSD}')
  ZOPEN_CHECK_TIMEOUT  Timeout limit in seconds for the check program (defaults to '${ZOPEN_CHECK_TIMEOUTD}')
  ZOPEN_IMAGE_REGISTRY Docker image registry to an OCI image to (use with --oci option)
  ZOPEN_IMAGE_DOCKERFILE_NAME Dockerfile name (default: Dockerfile)
  ZOPEN_IMAGE_DOCKER_NAME Docker/podman tool name (default: podman)
  ZOPEN_IMAGE_REGISTRY_ID The ID to authenticate to the Docker image registry (use with --oci option)
  ZOPEN_IMAGE_REGISTRY_KEY_FILE The file containing the key to authenticate to the Docker image registry (use with --oci option)
  ZOPEN_LOG_DIR        The directory to store build logs (defaults to '${ZOPEN_ROOT}/log')
  ZOPEN_INSTALL        Installation program to run. If skip is specified, no installation step is performed (defaults to '${ZOPEN_INSTALLD}')
  ZOPEN_INSTALL_OPTS   Options to pass to installation program (defaults to '${ZOPEN_INSTALL_OPTSD}')
  ZOPEN_CLEAN          Clean up program to run (defaults to '${ZOPEN_CLEAND}')
  ZOPEN_CLEAN_OPTS     Options to pass to clean up  program (defaults to '${ZOPEN_CLEAN_OPTSD}')
  ZOPEN_SHELL          Specify an alternate shell to use if -s option specified (defaults to /bin/sh)"

}

printFunctions() {
	echo "User-Provided functions:
  zopen_init                  This function runs after code is downloaded and patched but before the code is built.
  zopen_post_buildenv         This function runs after the 'buildenv' is processed.
  zopen_pre_patch             This function runs before the 'patch' step of the build is run.
  zopen_pre_check             This function runs before the 'check' step of the build is run.
  zopen_pre_build             This function runs before the 'make' step of the build is run.
  zopen_append_to_env         This function runs as part of generation of the .env file. The output of the function is appended to .env
  zopen_append_to_setup       This function runs as part of generation of the setup.sh file. The output of the function is appended to setup.sh
  zopen_append_to_validate_install This function runs as part of generation of the install_test.sh file. The output of the function is appended to install_test.sh script.
  zopen_pre_install           This function runs before the 'install' step of the build is run.
  zopen_post_install          This function runs after the 'install' step of the build is run.
  zopen_check_results         This function runs after the 'check' step of the build is run and must print out expected and actual failures.
  zopen_get_version           This function returns the version of the tool in accordance with semantic versioning
  zopen_append_to_zoslib_env  This function runs as part of generation of the C function zoslib_env_hook, which can be used to set environment variables before main is run."
}

# Temporary files
for tmp in "$TMPDIR" "$TMP" /tmp; do
	if [ ! -z $tmp ] && [ -d $tmp ]; then
		break
	fi
done

if [ ! -d "$tmp" ]; then
	printError "Temporary directory not found. Please specify \$TMPDIR, \$TMP or have a valid /tmp directory"
fi

TMP_FIFO_PIPE="$tmp/$LOGNAME.pipe"
ZOPEN_TEMP_C_FILE="$tmp/$LOGNAME.c"

# Capture start time before setting trap
fullBuildStartTime=$SECONDS

# Remove temoraries on exit and report elapsed time
cleanupOnExit() {
	rv=$?
	[ -f $ZOPEN_TEMP_C_FILE ] && rm -rf $ZOPEN_TEMP_C_FILE
	[ -p $TMP_FIFO_PIPE ] && rm -rf $TMP_FIFO_PIPE
	if [ ! -z "$TEE_PID" ]; then
		if kill -0 $TEE_PID 2>/dev/null; then
			kill -9 $TEE_PID
		fi
	fi
	printElapsedTime info "zopen-build" $fullBuildStartTime
	trap - EXIT # clear the EXIT trap so that it's not double called
	exit $rv
}

trap "cleanupOnExit" EXIT INT TERM QUIT HUP

setDefaultBuild() {
	if [ ! -z "$ZOPEN_BUILD_LINE_OPT" ]; then
		ZOPEN_BUILD_LINE=$(echo "${ZOPEN_BUILD_LINE_OPT}" | tr '[a-z]' '[A-Z]')
	else
		ZOPEN_BUILD_LINE=$(echo "${ZOPEN_BUILD_LINE}" | tr '[a-z]' '[A-Z]')
	fi

	if [ ! -z "$ZOPEN_BUILD_LINE" ]; then
		printVerbose "Setting build to $ZOPEN_BUILD_LINE"
	fi
}

setDefaults() {
	export ZOPEN_BOOTSTRAPD="./bootstrap"
	export ZOPEN_BOOTSTRAP_OPTSD=""
	export ZOPEN_CONFIGURED="./configure"
	export ZOPEN_MAKED="make"
	export ZOPEN_CHECKD="make"
	export ZOPEN_CHECK_OPTSD="check"
	export ZOPEN_CHECK_TIMEOUTD="12600" # 3.5 hours
	export ZOPEN_INSTALLD="make"
	export ZOPEN_INSTALL_OPTSD="install"
	export ZOPEN_CLEAND="make"
	export ZOPEN_CLEAN_OPTSD="clean"
	if [ -z "$ZOPEN_IMAGE_DOCKERFILE_NAME" ]; then
		export ZOPEN_IMAGE_DOCKERFILE_NAME="Dockerfile"
	fi
	if [ -z "$ZOPEN_IMAGE_DOCKER_NAME" ]; then
		export ZOPEN_IMAGE_DOCKER_NAME="podman"
	fi
	export ZOPEN_TEST_STATUS_ALL_PASSED=0
	export ZOPEN_TEST_STATUS_MOST_PASSED=1
	export ZOPEN_TEST_STATUS_SOME_PASSED=2
	export ZOPEN_TEST_STATUS_NONE_PASSED=3
	export ZOPEN_TEST_STATUS_ERROR=4
	export ZOPEN_TEST_STATUS_SKIPPED=5
	unset ZOPEN_CPPFLAGS
	unset ZOPEN_CFLAGS
	unset ZOPEN_CXXFLAGS
	unset ZOPEN_LDFLAGS
	unset ZOPEN_LIBS
	unset ZOPEN_EXTRA_CPPFLAGS
	unset ZOPEN_EXTRA_CFLAGS
	unset ZOPEN_EXTRA_CXXFLAGS
	unset ZOPEN_EXTRA_LDFLAGS
	unset ZOPEN_EXTRA_LIBS
	return 0
}

printSyntax() {
	args=$*
	(
		echo ""
		echo "zopen-build is a general purpose build script to be used with the ZOSOpenTools ports."
		echo "The specifics of how the tool works can be controlled through environment variables."
		echo "The only environment variables you _must_ specify are to tell zopen-build where the "
		echo "  source is, and in what format type the source is stored."
		echo "By default, the environment variables are defined in a file named buildenv in the "
		echo "  root directory of the <package>port github repository"
		echo "To see a fully functioning z/OSOpenTools sample port"
		echo "  see: https://github.com/ZOSOpenTools/zotsampleport"
		echo ""
		echo "Syntax: zopen-build [<option>]*"
		echo "  where <option> may be one or more of:"
		echo "  -h: print this information"
		echo "  -v: run in verbose mode"
		echo "  -vv: run in very verbose mode (sets environment variables V=1 and VERBOSE=1)"
		echo "  -u|--upgradedeps: upgrade all dependencies by running zopen install"
		echo "  --buildtype: release|debug. The default is release"
		echo "  --build: dev|stable. This is the build line to build off of. If no build line is specified, it will use the ZOPEN_BUILD_LINE specified in the build, otherwise it will fallback to ZOPEN_TYPE."
		echo "  --comp: <compiler dependency>.  The compiler(s) used for building.  The default is comp_xlclang."
		echo "  --oci: build and publish an OCI image to \$ZOPEN_IMAGE_REGISTRY"
		echo "  -e <env file>: source <env file> instead of buildenv to establish build environment"
		echo "  -c|--clean: Deletes all of the build output and forces reconfigure with next build"
		echo "  -f|--force-rebuild: forces a rebuild, including running bootstrap and configure again"
		echo "  -g|--get-source: get the source and apply patch without building"
		echo "  -gp|--generate-pax: generate a pax.Z file based on the install contents"
		echo "  --forcepatchapply: force apply the patches, where rejected patches are placed into a corresponding file of the same name, with the .rej extension"
		echo "  --no-set-active: do not change the pinned version" >&2
		echo "  -s: exec a shell before running configure.  Useful when manually building ports."

		opts=$(printEnvVar)
		echo "${opts}"
		fns=$(printFunctions)
		echo "${fns}"
	) >&2
}

processOptions() {
	args=$*
	verbose=false
	publishOCI=false
	skipcheck=false
	buildInReleaseMode=true
	startShell=false
	cleanupBuild=false
	forceRebuild=false
	freshBuild=false
	buildEnvFile="./buildenv"
	getSourceOnly=false
	generatePax=false
	setActive=true
	forcePatchApply=false
	depsPath="$ZOPEN_PKGINSTALL"
	forceUpgradeDeps=false
	while [[ $# -gt 0 ]]; do
		case $1 in
		"-h" | "--h" | "-help" | "--help" | "-?" | "-syntax")
			trap - EXIT
			printSyntax "${args}"
			exit 0
			;;
		"--version")
			trap - EXIT
			zopen --version $ME
			exit 0
			;;
		"-v" | "--v" | "-verbose" | "--verbose")
			verbose=true
			;;
		"-vv" | "--vv" | "-veryverbose" | "--veryverbose")
			export V=1
			export VERBOSE=1
			verbose=true
			;;
		"-u" | "--upgradeDeps")
			forceUpgradeDeps=true
			;;
		"--forcepatchapply")
			forcePatchApply=true
			;;
		"-buildtype" | "--buildtype" | "-b")
			shift
			btype=$(echo "$1" | awk '{print toupper($0)}')
			if [ "$btype" = "DEBUG" ]; then
				buildInReleaseMode=false
			fi
			;;
		"-comp" | "--comp")
			shift
			ZOPEN_COMP=$1 # We will uppercase this later
			;;
		"-build" | "--build")
			shift
			ZOPEN_BUILD_LINE_OPT=$1
			;;
		"-oci" | "--oci")
			publishOCI=true
			;;
		"-sc" | "--skipcheck")
			skipcheck=true
			;;
		"-d" | "--depspath")
			shift
			depsPath="${1}|${depsPath}"
			;;
		"--no-set-active")
			setActive=false # Install package as normal but keep existing installation as active
			;;
		"-e" | "--env")
			shift
			buildEnvFile=$1
			;;
		"-c" | "--clean")
			cleanupBuild=true
			;;
		"-f" | "--force-rebuild")
			forceRebuild=true
			;;
		"-g" | "--get-source")
			getSourceOnly=true
			;;
		"-gp" | "--generate-pax")
			generatePax=true
			;;
		"-s" | "--shell")
			startShell=true
			;;
		*)
			printError "Unknown option ${arg} specified"
			;;
		esac
		shift
	done
}

loadBuildEnv() {
	if [ ! -r $buildEnvFile ]; then
		printError "Build environment file '$buildEnvFile' does not exist or is not readable"
	fi

	# Indicates to .env script that we're in zopen build
	export ZOPEN_IN_ZOPEN_BUILD=1

	. $buildEnvFile

	setDefaultBuild

	if command -V "zopen_post_buildenv" >/dev/null 2>&1; then
		printVerbose "Running zopen_post_buildenv"
		zopen_post_buildenv
	fi
}

checkEnv() {
	printHeader "Checking environment configuration"

	if [ ! -z "${ZOPEN_BUILD_LINE}" ]; then
		if [ "${ZOPEN_BUILD_LINE}x" = "DEVx" ]; then
			if [ -z "$ZOPEN_DEV_DEPS" ]; then
				printError "Building from dev, but ZOPEN_DEV_DEPS not specified"
			fi
			ZOPEN_DEPS="$ZOPEN_DEV_DEPS"
			if [ -z "$ZOPEN_DEV_URL" ]; then
				printError "Building from dev, but ZOPEN_DEV_URL not specified"
			fi
			ZOPEN_URL="$ZOPEN_DEV_URL"
			if [ ! -z "$ZOPEN_DEV_BRANCH" ]; then
				export ZOPEN_GIT_BRANCH="$ZOPEN_DEV_BRANCH"
			fi
			if [ ! -z "$ZOPEN_DEV_TAG" ]; then
				export ZOPEN_GIT_TAG="$ZOPEN_DEV_TAG"
			fi
			if [ ! -z "$ZOPEN_DEV_TYPE" ]; then
				export ZOPEN_TYPE="$ZOPEN_DEV_TYPE"
			else
				extension="${ZOPEN_URL##*.}"
				if [ "$extension" = "git" ]; then
					ZOPEN_TYPE="GIT"
				else
					ZOPEN_TYPE="TARBALL"
				fi
			fi
		elif [ "${ZOPEN_BUILD_LINE}x" = "STABLEx" ]; then
			if [ -z "$ZOPEN_STABLE_DEPS" ]; then
				printError "Building from stable, but ZOPEN_STABLE_DEPS not specified"
			fi
			ZOPEN_DEPS="$ZOPEN_STABLE_DEPS"
			if [ -z "$ZOPEN_STABLE_URL" ]; then
				printError "Building from stable, but ZOPEN_STABLE_URL not specified"
			fi
			ZOPEN_URL="$ZOPEN_STABLE_URL"
			if [ ! -z "$ZOPEN_STABLE_BRANCH" ]; then
				export ZOPEN_GIT_BRANCH="$ZOPEN_STABLE_BRANCH"
			fi
			if [ ! -z "$ZOPEN_STABLE_TAG" ]; then
				export ZOPEN_GIT_TAG="$ZOPEN_STABLE_TAG"
			fi
			if [ ! -z "$ZOPEN_STABLE_TYPE" ]; then
				export ZOPEN_TYPE="$ZOPEN_STABLE_TYPE"
			else
				extension="${ZOPEN_URL##*.}"
				if [ "$extension" = "git" ]; then
					ZOPEN_TYPE="GIT"
				else
					ZOPEN_TYPE="TARBALL"
				fi
			fi
		else
			printError "Unrecognized build line ${ZOPEN_BUILD_LINE}"
		fi
	else
		if [ "${ZOPEN_TYPE}x" = "TARBALLx" ]; then
			if [ ! -z "${ZOPEN_TARBALL_URL}" ]; then
				export ZOPEN_URL="${ZOPEN_TARBALL_URL}"
			fi
			if [ ! -z "${ZOPEN_TARBALL_DEPS}" ]; then
				export ZOPEN_DEPS="${ZOPEN_TARBALL_DEPS}"
			fi
			printHeader "Using tarball environment"
		elif [ "${ZOPEN_TYPE}x" = "GITx" ]; then
			if [ ! -z "${ZOPEN_GIT_URL}" ]; then
				export ZOPEN_URL="${ZOPEN_GIT_URL}"
			fi
			if [ ! -z "${ZOPEN_GIT_DEPS}" ]; then
				export ZOPEN_DEPS="${ZOPEN_GIT_DEPS}"
			fi
			printHeader "Using git environment"
		elif [ "${ZOPEN_TYPE}x" = "BAREx" ]; then
			printHeader "Using bare environment"
		else
			extension="${ZOPEN_URL##*.}"
			if [ "$extension" = "git" ]; then
				ZOPEN_TYPE="GIT"
			else
				ZOPEN_TYPE="TARBALL"
			fi
		fi
	fi

	ZOPEN_INIT_CODE="zopen_init"
	ZOPEN_PRE_CHECK_CODE="zopen_pre_check"
	ZOPEN_APPEND_TO_ENV_CODE="zopen_append_to_env"
	ZOPEN_APPEND_TO_ZOSLIB_ENV_CODE="zopen_append_to_zoslib_env"
	ZOPEN_APPEND_TO_SETUP_CODE="zopen_append_to_setup"
	ZOPEN_APPEND_TO_VALIDATE_CODE="zopen_append_to_validate_install"
	ZOPEN_PRE_BUILD_CODE="zopen_pre_build"
	ZOPEN_PRE_INSTALL_CODE="zopen_pre_install"
	ZOPEN_POST_INSTALL_CODE="zopen_post_install"
	ZOPEN_CHECK_RESULTS_CODE="zopen_check_results"

	if ! command -V "${ZOPEN_CHECK_RESULTS_CODE}" >/dev/null 2>&1; then
		if [ "${ZOPEN_CHECK}x" != "skipx" ] && ! ${skipcheck}; then
			export ZOPEN_CHECK_RESULTS_CODE="${ZOPEN_ROOT}/portchk.sh"
			if ! [ -x "${ZOPEN_CHECK_RESULTS_CODE}" ]; then
				printError "zopen_check_results script needs to be provided to check the results."
			fi
		fi
	fi

	implicitDeps="sed" # for replaceHardcodedPaths logic

	if [ "${ZOPEN_COMP}x" = "x" ]; then
		implicitDeps="$implicitDeps comp_xlclang"
	else
		# user specified, so normalize in lower case
		ZOPEN_COMP=$(echo "${ZOPEN_COMP}" | tr '[A-Z]' '[a-z]')
		implicitDeps="$implicitDeps comp_$ZOPEN_COMP"
	fi

	if [ "${ZOPEN_TYPE}x" = "TARBALLx" ]; then
		if [ "${ZOPEN_URL}x" = "x" ]; then
			printError "ZOPEN_STABLE_URL, ZOPEN_DEV_URL, ZOPEN_URL or ZOPEN_TARBALL_URL needs to be defined"
		fi
		if [ "${ZOPEN_DEPS}x" = "x" ]; then
			printError "ZOPEN_STABLE_DEPS, ZOPEN_DEV_DEPS, ZOPEN_DEPS or ZOPEN_TARBALL_DEPS needs to be defined"
		fi
		implicitDeps="$implicitDeps git curl tar"
		ext=${ZOPEN_URL##*.}
		if [ "${ext}x" = "xzx" ]; then
			implicitDeps="${implicitDeps} xz"
		elif [ "${ext}x" = "gzx" -o "${ext}x" = "tgzx" ]; then
			implicitDeps="${implicitDeps} gzip"
		elif [ "${ext}x" = "bz2x" ]; then
			implicitDeps="${implicitDeps} bzip2"
		fi
		printVerbose "Implicitly adding tarball dependencies: ${implicitDeps}"
		ZOPEN_DEPS="${implicitDeps} ${ZOPEN_DEPS}"
	elif [ "${ZOPEN_TYPE}x" = "GITx" ]; then
		if [ "${ZOPEN_URL}x" = "x" ]; then
			printError "ZOPEN_STABLE_URL, ZOPEN_DEV_URL, ZOPEN_URL or ZOPEN_GIT_URL needs to be defined"
		fi
		if [ "${ZOPEN_DEPS}x" = "x" ]; then
			printError "ZOPEN_STABLE_DEPS, ZOPEN_DEV_DEPS, ZOPEN_DEPS or ZOPEN_GIT_DEPS needs to be defined"
		fi
		implicitDeps="$implicitDeps git"
		printVerbose "Implicitly adding git dependencies: ${implicitDeps}"
		ZOPEN_DEPS="${implicitDeps} ${ZOPEN_DEPS}"
	fi

	if ! [ -r "${ZOPEN_CA}" ]; then
		# Check local clone
		export ZOPEN_CA="${utilparentdir}/cacert.pem"
		if ! [ -r "${ZOPEN_CA}" ]; then
			printError "Internal Error. Certificate ${ZOPEN_CA} is required. Use zopen update-cacert to update."
		fi
	fi
}

setDepsEnv() {
	if command -V curl >/dev/null 2>&1; then
		curlpath=$(dirname "$(command -V curl | cut -f3 -d' ')")
	fi
	initDefaultEnvironment
	# Add base dependencies:
	# zopen bin, and curl
	export PATH="$utilparentdir/bin:$PATH"
	if $forceUpgradeDeps; then
		export PATH="$curlpath:$PATH"
	fi

	deps="${ZOPEN_DEPS}"

	orig="${PWD}"
	# Filter out duplicate deps
	deps=$(echo "$deps" | xargs | tr ' ' '\n' | sort -u)
	for dep in $deps; do
		printVerbose "Searching for dependency $dep"
		parseline=$(parseDeps $dep)
		dep=$(echo $parseline | awk -F'|' '{print $1}')
		operator=$(echo $parseline | awk -F'|' '{print $2}')
		requestedMajor=$(echo $parseline | awk -F'|' '{print $3}')
		requestedMinor=$(echo $parseline | awk -F'|' '{print $4}')
		requestedPatch=$(echo $parseline | awk -F'|' '{print $5}')
		requestedSubrelease=$(echo $parseline | awk -F'|' '{print $6}')
		requestedVersion="${requestedMajor}.${requestedMinor}.${requestedPatch}.${requestedSubrelease}"
		foundDep=false
		for path in $(echo ${depsPath} | tr '|' '\n'); do
			if [ -r "$path/${dep}/${dep}/.env" ]; then
				depdir="$path/${dep}/${dep}"
				versionPath="$depdir/.version"
				if [ -r "$versionPath" ]; then
					version=$(cat "$versionPath")
				fi
				# Avoid double sourcing the .env if we're forcing an upgrade on it
				if ! $forceUpgradeDeps; then
					if ! validateVersion "${version}" "$operator" "${requestedVersion}" "$depdir"; then
						continue
					fi

					printVerbose "Setting up ${depdir} dependency environment"
					cd "${depdir}" && . ./.env
					if [ $? -gt 0 ]; then
						printError "Failed to source ${depdir} .env"
					fi
				fi
				foundDep=true
				break
			fi
		done
		if ! $foundDep || $forceUpgradeDeps; then
			if ! $forceUpgradeDeps; then
				if [ -z "$operator" ]; then
					printWarning "Dependency $dep not found. Downloading via zopen install"
				else
					printWarning "Dependency $dep $operator ${requestedVersion} not found. Downloading via zopen install"
				fi
			else
				printHeader "Upgrading dependency $dep. Installing via zopen install"
			fi
			if [ -z "$curlpath" ]; then
				printError "Need curl to proceed with installation"
			fi
			path=$ZOPEN_PKGINSTALL # Install location
			if ! runAndLog "PATH=\"$curlpath:$PATH\" $MYDIR/zopen-install --install-or-upgrade $dep -v -y"; then
				printError "zopen install command failed"
			fi
			depdir="$path/${dep}/${dep}"
			printVerbose "Setting up upgraded $depdir dependency environment"
			cd "$depdir" && . ./.env
			if [ $? -gt 0 ]; then
				printError "Failed to source ${depdir} .env"
			fi
			versionPath="$depdir/.version"
			if [ -r "$versionPath" ]; then
				version=$(cat "$versionPath")
			fi
			if ! validateVersion "${version}" "$operator" "${requestedVersion}" "$depdir"; then
				printError "Dependency $depdir upgraded, but does not satisfy \"$operator\" \"${requestedVersion}\""
			fi
		fi
	done
	cd "${orig}" || exit 99
}

setEnv() {

	# Certificate information
	export SSL_CERT_FILE="${ZOPEN_CA}"
	export GIT_SSL_CAINFO="${ZOPEN_CA}"
	export CURL_CA_BUNDLE="${ZOPEN_CA}"

	setDepsEnv

	# Dependencies such as libraries may add flags
	export CPPFLAGS="${ZOPEN_CPPFLAGS} ${ZOPEN_EXTRA_CPPFLAGS}"
	export CFLAGS="${ZOPEN_CFLAGS} ${ZOPEN_EXTRA_CFLAGS}"
	export CXXFLAGS="${ZOPEN_CXXFLAGS} ${ZOPEN_EXTRA_CXXFLAGS}"
	export LDFLAGS="${ZOPEN_LDFLAGS} ${ZOPEN_EXTRA_LDFLAGS}"
	export LIBS="${ZOPEN_LIBS} ${ZOPEN_EXTRA_LIBS}"

	# For compatibility with the default 'make' /etc/startup.mk on z/OS
	export CCC="${CXX}"
	export CCCFLAGS="${CXXFLAGS}"

	# Some configure scripts act on *_FOR_BUILD flags
	export CC_FOR_BUILD="${CC}"
	export CXX_FOR_BUILD="${CXX}"
	export CPPFLAGS_FOR_BUILD="${CPPFLAGS}"
	export CFLAGS_FOR_BUILD="${CFLAGS}"
	export LDFLAGS_FOR_BUILD="${LDFLAGS}"
	export LIBS_FOR_BUILD="${LIBS}"

	if [ "${ZOPEN_NUM_JOBS}x" = "x" ]; then
		ZOPEN_NUM_JOBS=$("${MYDIR}/numcpus.rexx")

		# Use half of the CPUs by default
		export ZOPEN_NUM_JOBS=$((ZOPEN_NUM_JOBS / 2))
	fi

	if [ $ZOPEN_NUM_JOBS -lt 1 ]; then
		export ZOPEN_NUM_JOBS=1
	fi

	if [ "${ZOPEN_BOOTSTRAP}x" = "x" ]; then
		export ZOPEN_BOOTSTRAP="${ZOPEN_BOOTSTRAPD}"
	fi
	if [ "${ZOPEN_BOOTSTRAP_OPTS}x" = "x" ]; then
		export ZOPEN_BOOTSTRAP_OPTS="${ZOPEN_BOOTSTRAP_OPTSD}"
	fi
	if [ "${ZOPEN_CONFIGURE}x" = "x" ]; then
		export ZOPEN_CONFIGURE="${ZOPEN_CONFIGURED}"
	fi
	if [ "${ZOPEN_MAKE}x" = "x" ]; then
		export ZOPEN_MAKE="${ZOPEN_MAKED}"
	fi
	if [ "${ZOPEN_MAKE_OPTS}x" = "x" ]; then
		export ZOPEN_MAKE_OPTS="-j${ZOPEN_NUM_JOBS}"
	fi
	if [ "${ZOPEN_CHECK}x" = "x" ]; then
		export ZOPEN_CHECK="${ZOPEN_CHECKD}"
	fi
	if [ "${ZOPEN_CHECK_TIMEOUT}x" = "x" ]; then
		export ZOPEN_CHECK_TIMEOUT="${ZOPEN_CHECK_TIMEOUTD}"
	fi
	if [ "${ZOPEN_CHECK_OPTS}x" = "x" ]; then
		export ZOPEN_CHECK_OPTS="${ZOPEN_CHECK_OPTSD}"
	fi
	if [ "${ZOPEN_INSTALL}x" = "x" ]; then
		export ZOPEN_INSTALL="${ZOPEN_INSTALLD}"
	fi
	if [ "${ZOPEN_INSTALL_OPTS}x" = "x" ]; then
		export ZOPEN_INSTALL_OPTS="-j${ZOPEN_NUM_JOBS} ${ZOPEN_INSTALL_OPTSD}"
	fi
	if [ "${ZOPEN_CLEAN}x" = "x" ]; then
		export ZOPEN_CLEAN="${ZOPEN_CLEAND}"
	fi
	if [ "${ZOPEN_CLEAN_OPTS}x" = "x" ]; then
		export ZOPEN_CLEAN_OPTS="${ZOPEN_CLEAN_OPTSD}"
	fi
	LOG_PFX=$(date +%C%y%m%d_%H%M%S)
}

#
# Tag files that we do not plan to put under 'git' for patching as binary
#
tagBinaryFiles() {
	absdir="$1"
	(cd "${absdir}" && find . -name "*.pdf" -o -name "*.png" -o -name "*.jpg" -o -name "*.gif" -o -name "*.ttf" -o -name "*.wbmp" -o -name "*.gmo" -o -name "*.po" -o -name "*.der" -o -name "*.xz" -o -name "*.gz" ! -type d ! -type l | xargs -I {} chtag -b {})
}

#
# 'Quick' way to tag binary files. If the list of extensions grows, something more
# elegant is required
#
tagTree() {
	dir="$1"
	absdir=$(cd ${dir} && echo "${PWD}")
	tagBinaryFiles "${absdir}"
}

checkGitVersion() {
	if ! git --version >/dev/null 2>/dev/null; then
		printError "git is required to download from the git repo"
	fi
	gitraw=$(git --version | awk '{print $3;}')
	v=${gitraw%%.*}
	vr=${gitraw%.*}
	r=${vr##*.}
	if [ ${v} -lt 2 ] || [ ${r} -lt 39 ]; then
		printError "Need to be running at least git 2.39"
	fi
}

gitClone() {
	gitname=$(basename "$ZOPEN_URL")
	dir=${gitname%%.*}
	if [ -d "${dir}" ]; then
		printInfo "Using existing git clone'd directory ${dir}"
	else
		freshBuild=true
		printInfo "Clone and create ${dir}"
		if [ "$ZOPEN_CLONE_SUBMODULES" = "yes" ]; then
			gitOptions=" --recurse-submodules"
		fi
		if ! runAndLog "git clone \"${ZOPEN_URL}\" $gitOptions"; then
			printError "Unable to clone ${gitname} from ${ZOPEN_URL}"
		fi
		if [ "${ZOPEN_GIT_BRANCH}x" != "x" ]; then
			if ! git -C "${dir}" checkout "${ZOPEN_GIT_BRANCH}" >/dev/null; then
				printError"Unable to checkout ${ZOPEN_URL} branch ${ZOPEN_GIT_BRANCH}"
			fi
		elif [ "${ZOPEN_GIT_TAG}x" != "x" ]; then
			if ! git -C "${dir}" checkout tags/"${ZOPEN_GIT_TAG}" -b "${ZOPEN_GIT_TAG}" >/dev/null; then
				printError"Unable to checkout ${ZOPEN_URL} tag ${ZOPEN_GIT_TAG}"
			fi
		fi
		tagTree "${dir}"
	fi
	echo "${dir}"
}

extractTarBall() {
	tarballz="$1"
	dir="$2"

	if ! tar --version >/dev/null 2>/dev/null; then
		printError "The tar open source package is required by zopen-build. The z/OS default 'tar' is insufficient"
	fi
	tarraw=$(tar --version | head -1 | awk '{print $4;}')
	v=${tarraw%%.*}
	r=${tarraw##*.}
	if [ ${v} -lt 1 ] || [ ${r} -lt 34 ]; then
		printError "Need to be running at least tar 1.34"
	fi

	printInfo "Extract tarball ${tarballz} into ${dir}"

	tar -axf "${tarballz}"
	if [ $? -gt 0 ]; then
		printError "Unable to untar ${tarballz}"
	fi
	rm -f "${tarballz}"

	tagTree "${dir}"
	cd "${dir}" || printError "Cannot cd to ${dir}"

	# Clean up .git* files since we will be creating our own local git repo for applying patches
	rm -rf .git* .travis*

	#
	# Need to keep this line and 'tagBinaryFiles' in sync
	# Perhaps this can be done with a function but be aware of blanks, newlines, etc. in file names
	#
	if [ "${ZOPEN_GIT_SETUP}x" = "Nx" ]; then
		if ! git init -b main . >/dev/null || ! git commit --allow-empty -m "Create Empty Repository for patch management" >/dev/null; then
			printError "Unable to initialize empty git repository for tarball"
		fi
	else
		if ! git init -b main . >/dev/null; then
			printError "Unable to initialize git repository for tarball"
		fi

		if ! asciiecho "
* text  working-tree-encoding=UTF-8
*.jpg binary
*.dvi binary
*.xz binary
*.gz binary
*.jpeg binary
*.png binary
*.gif binary
*.pdf binary
*.ttf binary
*.wbmp binary
*.gmo binary
*.po binary
*.der binary
" ".gitattributes"; then
			printError "Unable to create .gitattributes for tarball"
		fi

		if ! git add . >/dev/null; then
			printError "Unable to add files for git repository"
		fi

		if ! git commit --allow-empty -m "Create Repository for patch management" >/dev/null; then
			printError "Unable to commit git repository"
		fi
	fi
}

downloadTarBall() {
	if ! curl --version >/dev/null; then
		printError "curl is required to download a tarball"
	fi
	tarballz=$(basename "$ZOPEN_URL")
	dir=${tarballz%%.tar.*}
	dir=${dir%%.tgz}
	if [ -d "${dir}" ]; then
		echo "Using existing tarball directory ${dir}" >&2
	else
		freshBuild=true
		if ${verbose}; then
			printVerbose "curl $ZOPEN_CURL_PARAMS -L -o ${tarballz} ${ZOPEN_URL}"
		fi
		#
		# Some older tarballs (openssl) contain a pax_global_header file. Remove it
		# in advance so that unzip won't fail
		#
		rm -f pax_global_header

		#
		# Some sites fail on the first call because the name resolver hasn't resolved.
		# Make a first call to just get the headers and toss everything out just to
		# set up the cache (requirec for openssl)
		#
		curlCmd -I "${ZOPEN_URL}" >/dev/null 2>&1

		if ! curlCmd -L -0 -o "${tarballz}" "${ZOPEN_URL}"; then
			if [ -f "${tarballz}" ] && [ $(wc -c "${tarballz}" | awk '{print $1}') -lt 1024 ]; then
				cat "${tarballz}" >/dev/null
			else
				printError "Re-try curl for diagnostics"
				curlCmd -L -0 -o /dev/null "${ZOPEN_URL}"
			fi
			printError "Unable to download ${tarballz} from ${ZOPEN_URL}"
		fi
		# curl tags the file as ISO8859-1 (oops) so the tag has to be removed
		chtag -b "${tarballz}"

		extractTarBall "${tarballz}" "${dir}"
	fi
}

#
# This function applies patches previously created.
# To _create_ a patch, do the following:
#  -If required, create a sub-directory in the ${ZOPEN_ROOT}/patches directory called PR<x>, where <x> indicates
#   the order of the pull-request (e.g. if PR3 needs to be applied before your PR, make sure your PR
#   is at least PR4)
#  -Create, or update the PR readme called ${ZOPEN_ROOT}/patches/PR<x>/README.md describing this patch
#  -For each file you have changed:
#   -cd to the code directory and perform git diff <filename> >${ZOPEN_ROOT}/patches/PR<x>/<filename>.patch
#
applyPatches() {
	if [ "${ZOPEN_TYPE}x" = "BAREx" ]; then
		return 0
	fi
	printHeader "Applying patches"
	if [ "${ZOPEN_TYPE}x" = "TARBALLx" ]; then
		tarballz=$(basename "$ZOPEN_URL")
		root_loc=${tarballz%%.tar.*}
		root_loc=${root_loc%%.tgz}
		code_dir="${ZOPEN_ROOT}/${root_loc}"
	else
		gitname=$(basename "$ZOPEN_URL")
		code_dir="${ZOPEN_ROOT}/${gitname%%.*}"
	fi

	if [ ! -z "$ZOPEN_BUILD_LINE" ]; then
		buildtype_lower=$(echo "${ZOPEN_BUILD_LINE}" | tr '[A-Z]' '[a-z]')
		patch_try_dir="${ZOPEN_ROOT}/${buildtype_lower}-patches"
		if [ -d "$patch_try_dir" ]; then
			patch_dir="$patch_try_dir"
		fi
	fi

	if [ -z "$patch_dir" ]; then
		patch_dir="${ZOPEN_ROOT}/patches"
		if ! [ -d "${patch_dir}" ]; then
			printWarning "${patch_dir} does not exist - no patches to apply"
			return 0
		fi
	fi

	printVerbose "Using patch directory $patch_dir"

	moved=false
	if [ -d "${code_dir}/.git-for-patches" ] && ! [ -d "${code_dir}/.git" ]; then
		mv "${code_dir}/.git-for-patches" "${code_dir}/.git" || exit 99
		moved=true
	fi

	if ! [ -d "${code_dir}/.git" ]; then
		printWarning "applyPatches requires ${code_dir} to be git-managed but there is no .git directory. No patches applied"
		return 0
	fi

	patches=$( (cd "${patch_dir}" && find . -name "*.patch" | sort))
	if [ "${patches}x" = "x" ]; then
		printWarning "No patches in ${patch_dir} to apply"
		return 0
	fi
	results=$( (cd "${code_dir}" && git status --porcelain --untracked-files=no 2>&1))
	failedcount=0
	if [ "${results}" != '' ]; then
		printInfo "Existing Changes are active in ${code_dir}."
		printInfo "To re-apply patches, perform a git reset on ${code_dir} prior to running applyPatches again."
		return 0
	else
		for patch in $patches; do
			p="${patch_dir}/${patch}"

			patchsize=$(wc -c "${p}" | awk '{ print $1 }')
			if [ ${patchsize} -eq 0 ]; then
				printWarning "Warning: patch file ${p} is empty - nothing to be done"
			else
				printInfo "Applying ${p}"
				if $forcePatchApply; then
					(cd "${code_dir}" && git apply --reject "${p}" 2>&1)
				else
					if ! out=$( (cd "${code_dir}" && git apply --check "${p}" 2>&1 && git apply "${p}" 2>&1)); then
						printSoftError "Patch of make tree failed (${p})."
						printSoftError "${out}"
						failedcount=$((failedcount + 1))
						break
					fi
				fi
			fi
		done
	fi

	# Tag the files that were just updated (again) as ASCII (hopefully can remove after we build our own git)
	(cd "${code_dir}" && git status --untracked-files -s | awk '{ $1=""; print; }' | xargs -I {} chtag -tcISO8859-1 {})
	if ${moved}; then
		mv "${code_dir}/.git" "${code_dir}/.git-for-patches" || exit 99
	fi

	if [ $failedcount -ne 0 ]; then
		exit $failedcount
	fi
	return 0
}

getCode() {
	printHeader "Building ${ZOPEN_ROOT}"
	cd "${ZOPEN_ROOT}" || exit 99

	if [ "${ZOPEN_TYPE}x" = "BAREx" ]; then
		return 0
	fi

	checkGitVersion

	if [ "${ZOPEN_TYPE}x" = "GITx" ]; then
		printInfo "Checking if git directory already cloned"
		if ! gitClone; then
			return 4
		fi
	elif [ "${ZOPEN_TYPE}x" = "TARBALLx" ]; then
		printInfo "Checking if tarball already downloaded"
		if ! downloadTarBall; then
			return 4
		fi
	else
		printError "ZOPEN_TYPE should be one of GIT or TARBALL"
		return 4
	fi
}

create_fifo_pipe() {
	file="$1"
	if [ -p $TMP_FIFO_PIPE ]; then
		rm $TMP_FIFO_PIPE
	fi
	mkfifo $TMP_FIFO_PIPE
	chtag -tc 819 $TMP_FIFO_PIPE
	touch ${file} && chtag -tc 819 ${file}
	tee ${file} <$TMP_FIFO_PIPE &
	TEE_PID=$!
}

cleanup() {
	if [ -n "${ZOPEN_CLEAN_CMD}" ] && [ -f "${ZOPEN_LOG_DIR}/config.success" ] && ! $freshBuild; then
		printHeader "Running Cleanup"
		cleanlog="${ZOPEN_LOG_DIR}/${LOG_PFX}_clean.log"
		create_fifo_pipe "${cleanlog}"
		if ! runAndLog "${ZOPEN_CLEAN_CMD} >$TMP_FIFO_PIPE 2>&1"; then
			printError "Cleanup failed. Log: ${cleanlog}" >&2
		fi
	fi
	rm -f ${ZOPEN_LOG_DIR}/bootstrap.success
	rm -f ${ZOPEN_LOG_DIR}/config.success
}

bootstrap() {
	bootstrapStartTime=$SECONDS
	if [ -n "${ZOPEN_BOOTSTRAP_CMD}" ]; then
		printHeader "Running Bootstrap"
		if [ -r "${ZOPEN_LOG_DIR}/bootstrap.success" ]; then
			echo "Using previous successful bootstrap. Specify -f to force a bootstrap." >&2
		else
			bootlog="${ZOPEN_LOG_DIR}/${LOG_PFX}_bootstrap.log"
			create_fifo_pipe "${bootlog}"
			if ! runAndLog "${ZOPEN_BOOTSTRAP_CMD} >$TMP_FIFO_PIPE 2>&1"; then
				printError "Bootstrap failed. Log: ${bootlog}" >&2
			fi
			touch ${ZOPEN_LOG_DIR}/bootstrap.success
		fi
	else
		printHeader "Skip Bootstrap"
	fi
	printElapsedTime verbose "bootstrap" $bootstrapStartTime

}

configure() {
	configureStartTime=$SECONDS
	if [ -n "${ZOPEN_CONFIGURE_CMD}" ]; then
		printHeader "Running Configure"
		if [ -r "${ZOPEN_LOG_DIR}/config.success" ]; then
			echo "Using previous successful configuration. Specify -f to force a configure." >&2
		else
			configlog="${ZOPEN_LOG_DIR}/${LOG_PFX}_config.log"
			create_fifo_pipe "${configlog}"
			if ! runAndLog "${ZOPEN_CONFIGURE_CMD} >$TMP_FIFO_PIPE 2>&1"; then
				if [ "${ZOPEN_CONFIGURE_MINIMAL}" = "yes" ]; then
					printError "Configure (minimal) failed. Log: ${configlog}"
				else
					printError "Configure (full) failed. Log: ${configlog}"
				fi
			fi
			touch ${ZOPEN_LOG_DIR}/config.success
		fi
	else
		printHeader "Skip Configure"
	fi
	printElapsedTime verbose "configure" $configureStartTime
}

build() {
	buildStartTime=$SECONDS
	if command -V "${ZOPEN_PRE_BUILD_CODE}" >/dev/null 2>&1; then
		printVerbose "Running ${ZOPEN_PRE_BUILD_CODE}"
		if ! "${ZOPEN_PRE_BUILD_CODE}"; then
			printError "Pre build failed."
		fi
	fi

	makelog="${ZOPEN_LOG_DIR}/${LOG_PFX}_build.log"
	if [ -n "${ZOPEN_MAKE_CMD}" ]; then
		printHeader "Running Build"
		create_fifo_pipe "${makelog}"
		if ! runAndLog "${ZOPEN_MAKE_CMD} > $TMP_FIFO_PIPE 2>&1"; then
			if [ "${ZOPEN_MAKE_MINIMAL}" = "yes" ]; then
				printError "Make (minimal) failed. Log: ${makelog}"
			else
				printError "Make (full) failed. Log: ${makelog}"
			fi
		fi
	else
		printHeader "Skipping Build"
	fi
	printElapsedTime verbose "build" $buildStartTime
}

check() {
	checkStartTime=$SECONDS
	if command -V "${ZOPEN_PRE_CHECK_CODE}" >/dev/null 2>&1; then
		printVerbose "Running ${ZOPEN_PRE_CHECK_CODE}"
		"${ZOPEN_PRE_CHECK_CODE}" "${ZOPEN_INSTALL_DIR}"
	fi
	checklog="${ZOPEN_LOG_DIR}/${LOG_PFX}_check.log"
	results=$ZOPEN_TEST_STATUS_SKIPPED # skipped
	if [ -n "${ZOPEN_CHECK_CMD}" ]; then
		printHeader "Running Check"
		create_fifo_pipe "${checklog}"
		runInBackgroundWithTimeoutAndLog "${ZOPEN_CHECK_CMD} > $TMP_FIFO_PIPE 2>&1" "${ZOPEN_CHECK_TIMEOUT}"
		if command -V "${ZOPEN_CHECK_RESULTS_CODE}" >/dev/null 2>&1; then
			testStatus="$(${ZOPEN_CHECK_RESULTS_CODE} "${ZOPEN_LOG_DIR}" "${LOG_PFX}")"
			printVerbose "Test status:\n$testStatus"
			testStatusError=false
			checkTotalTests=false
			if echo "$testStatus" | grep -q -E "actualFailures:[ ]*[0-9]+"; then
				failures=$(echo "$testStatus" | grep "actualFailures:" | sed -e "s/.*actualFailures://" | tr -d ' ')
			else
				printSoftError "${ZOPEN_CHECK_RESULTS_CODE} needs to emit an actualFailures:<number> line"
				testStatusError=true
			fi
			if echo "$testStatus" | grep -q -E "expectedFailures:[ ]*[0-9]+"; then
				expectedFailures=$(echo "$testStatus" | grep "expectedFailures:" | sed -e "s/.*expectedFailures://" | tr -d ' ')
			else
				printSoftError "${ZOPEN_CHECK_RESULTS_CODE} needs to emit an expectedFailures:<number> line"
				testStatusError=true
			fi
			if echo "$testStatus" | grep -q -E "totalTests:[ ]*[0-9]+"; then
				totalTests=$(echo "$testStatus" | grep "totalTests:" | sed -e "s/.*totalTests://" | tr -d ' ')
				if [ $totalTests -eq 0 ]; then
					printSoftError "Total tests is 0"
					testStatusError=true
				fi
			else
				printSoftError "${ZOPEN_CHECK_RESULTS_CODE} needs to emit an totalTests:<number> line"
				testStatusError=true
			fi
			if echo "$testStatus" | grep -q -E "expectedTotalTests:[ ]*[0-9]+"; then
				expectedTotalTests=$(echo "$testStatus" | grep "expectedTotalTests:" | sed -e "s/.*expectedTotalTests://" | tr -d ' ')
				checkTotalTests=true
			fi
			if ${testStatusError}; then
				printError "Test Status:\n$testStatus"
			fi
			success="$((totalTests - failures))"
			percent="$(echo "$success" "$totalTests" | awk '{printf "%.0f", $1 * 100 / $2}')"
			percenthundreth="$(echo "$success" "$totalTests" | awk '{printf "%.2f", $1 * 100 / $2}')"
			summary="$success tests pass out of $totalTests tests - ${percenthundreth}% success rate"
			printVerbose "Test results: $summary"
			if ! [ $percent -eq $percent ]; then # not a number
				results=$ZOPEN_TEST_STATUS_ERROR
				ZOPEN_STATUS="Error (could not run tests)" # bad return code from check results
			else
				if [ $percent -eq 100 ]; then
					results=$ZOPEN_TEST_STATUS_ALL_PASSED
					ZOPEN_STATUS="Green ($summary)" # All tests passed
				elif [ $percent -ge 50 ]; then
					results=$ZOPEN_TEST_STATUS_MOST_PASSED
					ZOPEN_STATUS="Blue ($summary)" # Most tests passed
				elif [ $percent -eq 0 ]; then
					results=$ZOPEN_TEST_STATUS_NONE_PASSED
					ZOPEN_STATUS="Red ($summary)" # Pretty much non-functional
				elif [ $percent -lt 50 ]; then
					results=$ZOPEN_TEST_STATUS_SOME_PASSED
					ZOPEN_STATUS="Yellow ($summary)" # Most tests failed
				fi
			fi
			if ${checkTotalTests}; then
				if [ $totalTests -lt $expectedTotalTests ]; then
					printElapsedTime verbose "check" $checkStartTime
					printError "Executed tests ($totalTests) is less than expected ($expectedTotalTests). Failing..."
				fi
			fi
			if [ $failures -le $expectedFailures ]; then
				printElapsedTime verbose "check" $checkStartTime
				return 0
			else
				printElapsedTime verbose "check" $checkStartTime
				printError "Failures ($failures) not less than than expected ($expectedFailures). Failing..."
			fi
		fi
	else
		printHeader "Skipping Check"
		ZOPEN_STATUS="Skipped (tests skipped)" # Skipped tests
	fi
	printElapsedTime verbose "check" $checkStartTime
}

replaceHardcodedPath() {
	orig=$1
	replaced=$2
	f=$3
	hasHardcodedPaths=true
	printVerbose "Replacing $orig in $f"
	# only substitute text
	if /bin/sed -e "" $f 2>/dev/null 1>&2; then
		isWritable=true
		if [ ! -w "$f" ]; then
			isWriteable=false
			chmod "+w" $f
		fi
		cp $f $f.old &&
			# replace hardcoded path and strip out the -suffix in name to match active
			sed -e "s#${orig}/\([^/]\+\)/[^/\n '\";]*#${replaced}/\1/\1#g" $f.old >$f &&
			rm $f.old
		if ! $isWriteable; then
			chmod "-w" $f
		fi
	fi
}

replaceHardcodedPaths() {
	ZOPEN_INSTALL_PREFIX="${ZOPEN_INSTALL_DIR}/../../"
	ZOPEN_INSTALL_PREFIX=$(cd "${ZOPEN_INSTALL_PREFIX}" >/dev/null 2>&1 && pwd -P)

	printHeader "Replacing hardcoded ${ZOPEN_INSTALL_PREFIX} path"
	hasHardcodedPaths=false
	for f in $(find ${ZOPEN_INSTALL_DIR}/ -type f | xargs grep -l "${ZOPEN_INSTALL_PREFIX}" 2>/dev/null); do
		hasHardcodedPaths=true
		replaceHardcodedPath "${ZOPEN_INSTALL_PREFIX}" "ZOPEN_INSTALL_PREFIX" "$f"
	done
}

createEnvAndSetup() {
	printHeader "Creating ${ZOPEN_INSTALL_DIR}/.env"
	projectName=$(echo $ZOPEN_NAME | cut -d "-" -f 1 | awk '{print toupper($0)}')
	cat <<zz >"${ZOPEN_INSTALL_DIR}/.env"
if ! [ -f ./.env ]; then
  echo "Need to source from the .env directory" >&2
  return 0
fi

dropTagRedirEnvar=false
if [ "\${_BPX_TERMPATH-x}" = "OMVS" ] && [ -z "\$_TAG_REDIR_OUT" ]; then
  dropTagRedirEnvar=true;
fi

export _TAG_REDIR_IN=txt
export _TAG_REDIR_ERR=txt
export _TAG_REDIR_OUT=txt

deleteDuplicateEntries()
{
  value=\$1
  delim=\$2
  echo "\$value\$delim" | awk -v RS="\$delim" '!(\$0 in a) {a[\$0]; printf("%s%s", col, \$0); col=RS; }' | sed "s/\${delim}$//"
}

_CEE_RUNOPTS="\$_CEE_RUNOPTS FILETAG(AUTOCVT,AUTOTAG) POSIX(ON)"
# Remove spaces in between brackets
_CEE_RUNOPTS="\$(echo "\$_CEE_RUNOPTS" | awk '{gsub(/\([ \t]*/, "("); gsub(/[ \t]*\)/, ")"); gsub(/[ \t]*,[ \t]*/, ","); print}')"
export _CEE_RUNOPTS="\$(deleteDuplicateEntries "\$_CEE_RUNOPTS" " ")"

export ${projectName}_HOME="\${PWD}"
zz

	if [ -d "${ZOPEN_INSTALL_DIR}/bin" ]; then
		echo "PATH=\"\${${projectName}_HOME}/bin:\$PATH\"" >>"${ZOPEN_INSTALL_DIR}/.env"
		echo "export PATH=\"\$(deleteDuplicateEntries \"\$PATH\" \":\")\"" >>"${ZOPEN_INSTALL_DIR}/.env"
	fi
	if [ -d "${ZOPEN_INSTALL_DIR}/lib" ]; then
		echo "LIBPATH=\"\${${projectName}_HOME}/lib:\$LIBPATH\"" >>"${ZOPEN_INSTALL_DIR}/.env"
		echo "export LIBPATH=\"\$(deleteDuplicateEntries \"\$LIBPATH\" \":\")\"" >>"${ZOPEN_INSTALL_DIR}/.env"
	fi
	if [ -d "${ZOPEN_INSTALL_DIR}/share/man" ] || [ "${projectName}" = "GIT" ]; then
		echo "MANPATH=\"\${${projectName}_HOME}/share/man:\$MANPATH\"" >>"${ZOPEN_INSTALL_DIR}/.env"
		echo "export MANPATH=\"\$(deleteDuplicateEntries \"\$MANPATH\" \":\")\"" >>"${ZOPEN_INSTALL_DIR}/.env"
	fi
	if command -V "${ZOPEN_APPEND_TO_ENV_CODE}" >/dev/null 2>&1; then
		printVerbose "Appending additional environment variables..."
		append_to_env="$(${ZOPEN_APPEND_TO_ENV_CODE})"
	else
		append_to_env="# nothing to do"
	fi

	echo "$append_to_env" >"${ZOPEN_INSTALL_DIR}/.appenv"
	echo ". ./.appenv" >>"${ZOPEN_INSTALL_DIR}/.env"

	cat <<zz >>"${ZOPEN_INSTALL_DIR}/.env"
if \$dropTagRedirEnvar; then
  unset _TAG_REDIR_OUT
fi
zz

	# Create setup.sh script
	projectName_lower=$(echo "${projectName}" | tr '[A-Z]' '[a-z]')
	cat <<zz >"${ZOPEN_INSTALL_DIR}/setup.sh"
#!/bin/sh
touch \".installing\"
. ./.env
echo \"Setting up ${projectName_lower}...\"
zz

	if $hasHardcodedPaths; then
		cat <<zz >>"${ZOPEN_INSTALL_DIR}/setup.sh"
if [ -f .replacedpath ]; then
  REPLACE_PREFIX_PATH="\$(cat .replacedpath | head -1)"
else
  REPLACE_PREFIX_PATH="ZOPEN_INSTALL_PREFIX"
fi

replaceHardcodedPath() {
  orig=\$1
  replaced=\$2
  root=\$3
  f=\$4
  if [ \"\$f\" != \"\${root}/setup.sh\" ] && [ \"\$f\" != \"\${root}/.env\" ]; then
    isWritable=true
    if [ ! -w "\$f" ]; then
      isWriteable=false
      chmod "+w" \$f
    fi
    cp \$f \$f.tmp && \\
    /bin/sed -e \"s#\${orig}#\${replaced}#g\" \$f.tmp > \$f && \\
    rm \$f.tmp;
    if ! \$isWriteable; then
      chmod "-w" \$f
    fi
  fi
}
ZOPEN_INSTALL_PREFIX="\$${projectName}_HOME/../../"
ZOPEN_INSTALL_PREFIX=\$(cd "\${ZOPEN_INSTALL_PREFIX}" >/dev/null 2>&1 && pwd -P)
for f in \$(/bin/find \$${projectName}_HOME/ -type f | /bin/xargs grep -l \"\$REPLACE_PREFIX_PATH\" 2>/dev/null); do
  replaceHardcodedPath "\$REPLACE_PREFIX_PATH" "\${ZOPEN_INSTALL_PREFIX}" "\$${projectName}_HOME" \$f
done
echo "\${ZOPEN_INSTALL_PREFIX}" > .replacedpath
zz
	fi

	if command -V "${ZOPEN_APPEND_TO_SETUP_CODE}" >/dev/null 2>&1; then
		printVerbose "Appending additional setup code..."
		append_to_setup="$(${ZOPEN_APPEND_TO_SETUP_CODE})"
		echo "$append_to_setup" >>"${ZOPEN_INSTALL_DIR}/setup.sh"
	fi

	cat <<zz >>"${ZOPEN_INSTALL_DIR}/setup.sh"
echo \"Setup completed.\"
touch \".installed\"
rm \".installing\"
zz

	echo "#!/bin/sh" >"${ZOPEN_INSTALL_DIR}/install_test.sh"
	if command -V "${ZOPEN_APPEND_TO_VALIDATE_CODE}" >/dev/null 2>&1; then
		printVerbose "Appending additional validate code..."
		append_to_validate="$(${ZOPEN_APPEND_TO_VALIDATE_CODE})"
		echo "$append_to_validate" >>"${ZOPEN_INSTALL_DIR}/install_test.sh"
	fi
	cat <<zz >>"${ZOPEN_INSTALL_DIR}/install_test.sh"
exit 0;
zz

	if [ ! -z "$ZOPEN_RUNTIME_DEPS" ]; then
		cat <<ZZ >>"${ZOPEN_INSTALL_DIR}/.env"
if [ -f ".depsenv" ] && [ -z "\$ZOPEN_SOURCING_DEPS" ] ; then
  ZOPEN_SOURCING_DEPS=1
  . ./.depsenv
fi
if [ ! -z "\$ZOPEN_SOURCING_DEPS" ]; then
  unset ZOPEN_SOURCING_DEPS
fi
ZZ
		printHeader "Install dependencies: $ZOPEN_RUNTIME_DEPS"
		varName=$(echo "$projectName" | sed -e "s/-/_/g")
		cat <<ZZ >>"${ZOPEN_INSTALL_DIR}/.depsenv"
${varName}_originalDir="\$OLDPWD"
ZZ
		echo "$ZOPEN_RUNTIME_DEPS" | xargs | tr ' ' '\n' | sort | while read dep; do
			# Use the first path specified in the dependency search list to install to
			if ! runAndLog "PATH=\"$curlpath:$PATH\" $MYDIR/zopen-install --install-or-upgrade $dep -v --no-deps -y"; then
				printError "Failed to install dependencies"
			fi
			cat <<ZZ >>"${ZOPEN_INSTALL_DIR}/.depsenv"
if [ -f "../../${dep}/${dep}/.env" ]; then
  if [[ \$(type echo) == 'echo is a shell builtin' ]]; then
    pushd "../../${dep}/${dep}" >/dev/null
    . ./.env
    popd >/dev/null
  else
    cd "../../${dep}/${dep}" && . ./.env; cd - >/dev/null
  fi
fi
ZZ
		done
		cat <<ZZ >>"${ZOPEN_INSTALL_DIR}/.depsenv"
OLDPWD="\$${varName}_originalDir"
ZZ
	fi

	# Add call to setup.sh
	cat <<zz >>"${ZOPEN_INSTALL_DIR}/.env"
# Run setup.sh if it hasn't been run yet
if [ ! -f \".installed\" ] && [ ! -f \".installing\" ] && [ -x \"setup.sh\" ]; then
  ./setup.sh
fi
zz

	chmod 755 "${ZOPEN_INSTALL_DIR}/setup.sh"
}

createReadme() {
	printHeader "Creating ${ZOPEN_INSTALL_DIR}/README.md"
	cp "${MYDIR}/../data/README_header.md" "${ZOPEN_INSTALL_DIR}/README.md"
	if [ -f "${ZOPEN_ROOT}/README.md" ]; then
		cat "${ZOPEN_ROOT}/README.md" >>"${ZOPEN_INSTALL_DIR}/README.md"
	fi
	cat "${MYDIR}/../data/README_footer.md" >>"${ZOPEN_INSTALL_DIR}/README.md"
}

generatePropertiesJSON() {
	printHeader "Creating Properties JSON"
	package=$ZOPEN_NAME
	name=$(echo $package | cut -d "-" -f 1)
	version=$(echo $package | cut -d "-" -f 2)

	# Make the version OCI compat
	case "$version" in
	*.*.*.*) ;;
	*.*.*) version="$version.0" ;;
	*.*) version="$version.0.0" ;;
	*) version="1.0.0.0" ;;
	esac

	cat <<zz >"${ZOPEN_INSTALL_DIR}/properties.json"
{
"product": {
  "pax": "${ZOPEN_NAME}.${LOG_PFX}.zos.pax.Z",
  "name": "$name",
  "version": "$version",
  "release": "$LOG_PFX",
  "summary": "$name on z/OS",
  "description": "TODO"
}}
zz
	cp "${ZOPEN_INSTALL_DIR}/properties.json" "${ZOPEN_ROOT}/install/properties.json"
}

install() {
	installStartTime=$SECONDS
	if [ -n "${ZOPEN_INSTALL_CMD}" ]; then
		if [ -d "${ZOPEN_INSTALL_DIR}" ]; then
			printVerbose "${ZOPEN_INSTALL_DIR} already exists, deleting..."
			rm -rf "${ZOPEN_INSTALL_DIR}"
		fi
		if command -V "${ZOPEN_PRE_INSTALL_CODE}" >/dev/null 2>&1; then
			printVerbose "Running ${ZOPEN_PRE_INSTALL_CODE}"
			"${ZOPEN_PRE_INSTALL_CODE}" "${ZOPEN_INSTALL_DIR}"
		fi

		printHeader "Running Install"
		installlog="${ZOPEN_LOG_DIR}/${LOG_PFX}_install.log"
		create_fifo_pipe "${installlog}"
		if ! runAndLog "${ZOPEN_INSTALL_CMD} > $TMP_FIFO_PIPE 2>&1"; then
			printError "Install failed. Log: ${installlog}"
		fi
		replaceHardcodedPaths
		createEnvAndSetup

		if command -V "${ZOPEN_POST_INSTALL_CODE}" >/dev/null 2>&1; then
			printVerbose "Running ${ZOPEN_POST_INSTALL_CODE}"
			if ! "${ZOPEN_POST_INSTALL_CODE}" "${ZOPEN_INSTALL_DIR}"; then
				printError "Post install failed.${installlog}"
			fi
		fi

		createReadme

		# Store test.status into installed dir and build dir for cicd
		asciiecho "$ZOPEN_STATUS" "${ZOPEN_ROOT}/install/test.status"
		cp "${ZOPEN_ROOT}/install/test.status" "${ZOPEN_INSTALL_DIR}/test.status"

		if [ ! -z "${ZOPEN_BUILD_LINE}" ]; then
			asciiecho "${ZOPEN_BUILD_LINE}" "${ZOPEN_INSTALL_DIR}/.buildline"
		fi

		if [ -z "$(command -v zopen_get_version)" ]; then
			printWarning "A zopen_get_version() function should be defined in the buildenv to extract the version contents"
		else
			versionString=$(zopen_get_version)
			echo $versionString | awk -F. '{
        if (NF < 1 || NF > 4) {
          exit 1
        }
        if ($1 ~ /[^0-9]/) {
          exit 1
        }
        if ($2 ~ /[^0-9]/) {
          exit 1
        }
        if (NF >= 3 && $3 ~ /[^0-9A-Za-z-]+/) {
          exit 1
        }
        if (NF == 4 && $4 !~ /[0-9A-Za-z-]+/) {
          exit 1
        }
        exit 0
      }'

			if [ $? -ne 0 ]; then
				printError "$versionString uses an invalid version format"
			fi
			asciiecho "$versionString" "${ZOPEN_INSTALL_DIR}/.version"
			cp "${ZOPEN_INSTALL_DIR}/.version" "${ZOPEN_ROOT}/install/"
		fi

		if [ ! -z "$ZOPEN_RUNTIME_DEPS" ]; then
			asciiecho "$(echo "$ZOPEN_RUNTIME_DEPS" | xargs | tr ' ' '\n' | sort -u | xargs)" "${ZOPEN_INSTALL_DIR}/.runtimedeps"
			cp "${ZOPEN_INSTALL_DIR}/.runtimedeps" "${ZOPEN_ROOT}/install/"
		fi

		buildDeps="$ZOPEN_DEPS"
		asciiecho "$(echo "$buildDeps" | xargs | tr ' ' '\n' | sort -u | xargs)" "${ZOPEN_INSTALL_DIR}/.builddeps"
		cp "${ZOPEN_INSTALL_DIR}/.builddeps" "${ZOPEN_ROOT}/install/"

		asciiecho "$LOG_PFX" "${ZOPEN_INSTALL_DIR}/.buildtimestamp"

		generatePropertiesJSON

		if $generatePax; then
			printHeader "Generating pax.Z from ${ZOPEN_INSTALL_DIR}"
			if ! runAndLog "${ZOPEN_PAX_CMD}"; then
				printError "Could not generate pax \"${paxFileName}\""
			fi
		fi
		if $setActive; then
			PROJECT_NAME="$(echo ${ZOPEN_NAME} | cut -d'-' -f1)"
			mergeIntoSystem "$PROJECT_NAME" "${ZOPEN_INSTALL_DIR}" "$ZOPEN_ROOTFS"
			mkdir -p "$ZOPEN_ROOTFS/etc/profiled/$name"
			cat <<EOF >"$ZOPEN_ROOTFS/etc/profiled/$name/dotenv"
curdir=\$(pwd)
cd "${ZOPEN_INSTALL_DIR}" >/dev/null 2>&1
if [ -f ".appenv" ]; then
  . ./.appenv
fi
cd \$curdir  >/dev/null 2>&1
EOF
			printInfo "- Sourcing environment to run any setup"
			cd "${ZOPEN_INSTALL_DIR}" && ./setup.sh
			printVerbose "Marking this version as installed"
			touch "${ZOPEN_INSTALL_DIR}/.active"
		fi
		generateOCI $ZOPEN_NAME
	else
		printHeader "Skipping Install"
	fi
	printElapsedTime verbose "install" $installStartTime
}

#
# Figure out the 'bootstrap', 'configure', 'make', 'check', and 'install' commands here so that
# they are available within an interactive shell environment using --shell.
#
resolveCommands() {
	if [ -z "${ZOPEN_NAME}" ]; then
		ZOPEN_NAME="${dir}"
		if [ "${ZOPEN_TYPE}x" = "GITx" ]; then
			branch=$(git rev-parse --abbrev-ref HEAD 2>&1 | sed "s/\//./g")
			ZOPEN_NAME="${dir}-${branch}"
		fi
	fi
	# Check if ZOPEN_NAME contains a "-"
	if [ -z "$(echo "$ZOPEN_NAME" | grep '-')" ]; then
		# If not, add the '-DEV' suffix so as not to collide with zopen installed packages
		ZOPEN_NAME="${ZOPEN_NAME}-DEV"
	fi
	if [ "${ZOPEN_INSTALL_DIR}x" = "x" ]; then
		PROJECT_NAME="$(echo ${ZOPEN_NAME} | cut -d'-' -f1)"
		export ZOPEN_INSTALL_DIR="$ZOPEN_PKGINSTALL/${PROJECT_NAME}/${ZOPEN_NAME}" # Install into dev location
	fi
	if [ "${ZOPEN_LOG_DIR}x" = "x" ]; then
		export ZOPEN_LOG_DIR="${ZOPEN_ROOT}/log"
		if [ ! -z "${ZOPEN_BUILD_LINE}" ]; then
			ZOPEN_LOG_DIR="${ZOPEN_LOG_DIR}.${ZOPEN_BUILD_LINE}"
		fi
	fi

	[[ -d ${ZOPEN_LOG_DIR} ]] || mkdir -p ${ZOPEN_LOG_DIR}

	if [ "${ZOPEN_BOOTSTRAP}x" != "skipx" ] && [ ! -z "$(command -v ${ZOPEN_BOOTSTRAP})" ]; then
		export ZOPEN_BOOTSTRAP_CMD="\"${ZOPEN_BOOTSTRAP}\" ${ZOPEN_BOOTSTRAP_OPTS}"
	else
		unset ZOPEN_BOOTSTRAP_CMD
	fi

	if [ "${ZOPEN_CONFIGURE_OPTS}x" = "x" ]; then
		case "${ZOPEN_CONFIGURE}" in
		*cmake*)
			export ZOPEN_CONFIGURE_OPTS="--install-prefix ${ZOPEN_INSTALL_DIR} ${ZOPEN_EXTRA_CONFIGURE_OPTS}"
			;;
		*)
			export ZOPEN_CONFIGURE_OPTS="--prefix=${ZOPEN_INSTALL_DIR} ${ZOPEN_EXTRA_CONFIGURE_OPTS}"
			;;
		esac
	fi
	if [ "${ZOPEN_CONFIGURE}x" != "skipx" ]; then
		if [ "${ZOPEN_CONFIGURE_MINIMAL}x" = "x" ]; then
			case "${ZOPEN_CONFIGURE}" in
			*cmake*)
				export ZOPEN_CONFIGURE_CMD="\"${ZOPEN_CONFIGURE}\" ${ZOPEN_CONFIGURE_OPTS} -DCMAKE_C_COMPILER=${CC} -DCMAKE_C_FLAGS=\"${CPPFLAGS} ${CFLAGS}\" -DCMAKE_CXX_COMPILER=${CXX} -DCMAKE_CXX_FLAGS=\"${CPPFLAGS} ${CXXFLAGS}\" -DCMAKE_CXX_LINK_LIBRARY_FLAG=\"${LDFLAGS}\" -DCMAKE_C_LINK_LIBRARY_FLAG=\"${LDFLAGS}\" -DCMAKE_CXX_STANDARD_LIBRARIES=\"${LIBS}\" -DCMAKE_C_STANDARD_LIBRARIES=\"${LIBS}\""
				;;
			*)
				export ZOPEN_CONFIGURE_CMD="\"${ZOPEN_CONFIGURE}\" ${ZOPEN_CONFIGURE_OPTS} CC=${CC} CPPFLAGS=\"${CPPFLAGS}\" CFLAGS=\"${CFLAGS}\" CXX=${CXX} CXXFLAGS=\"${CXXFLAGS}\" LDFLAGS=\"${LDFLAGS}\" LIBS=\"${LIBS}\" LDLIBS=\"${LIBS}\""
				;;
			esac
			export ZOPEN_CONFIGURE_MINIMAL="no"
		else
			export ZOPEN_CONFIGURE_CMD="\"${ZOPEN_CONFIGURE}\" ${ZOPEN_CONFIGURE_OPTS}"
			export ZOPEN_CONFIGURE_MINIMAL="yes"
		fi
	else
		unset ZOPEN_CONFIGURE_CMD
		unset ZOPEN_CONFIGURE_MINIMAL_CMD
	fi

	verboseOpts=""
	if [ "$VERBOSE" -eq 1 ]; then
		verboseOpts="V=1"
	fi

	if [ "${ZOPEN_MAKE}x" != "skipx" ] && [ ! -z "$(command -v ${ZOPEN_MAKE})" ]; then
		if [ "${ZOPEN_MAKE_MINIMAL}x" = "x" ]; then
			export ZOPEN_MAKE_CMD="\"${ZOPEN_MAKE}\" ${ZOPEN_MAKE_OPTS} $verboseOpts CC=${CC} \"CPPFLAGS=${CPPFLAGS}\" \"CFLAGS=${CFLAGS}\" CXX=${CXX} \"CXXFLAGS=${CXXFLAGS}\" \"LDFLAGS=${LDFLAGS}\" \"LDLIBS=${LIBS}\""
			export ZOPEN_MAKE_MINIMAL="no"
		else
			export ZOPEN_MAKE_CMD="\"${ZOPEN_MAKE}\" ${ZOPEN_MAKE_OPTS}"
			export ZOPEN_MAKE_MINIMAL="yes"
		fi
	else
		unset ZOPEN_MAKE_CMD
	fi

	if [ "${ZOPEN_CHECK}x" != "skipx" ] && ! ${skipcheck}; then
		if [ "${ZOPEN_CHECK_MINIMAL}x" = "x" ]; then
			export ZOPEN_CHECK_CMD="\"${ZOPEN_CHECK}\" ${ZOPEN_CHECK_OPTS} $verboseOpts CC=${CC} \"CPPFLAGS=${CPPFLAGS}\" \"CFLAGS=${CFLAGS}\" CXX=${CXX} \"CXXFLAGS=${CXXFLAGS}\" \"LDFLAGS=${LDFLAGS}\""
		else
			export ZOPEN_CHECK_CMD="\"${ZOPEN_CHECK}\" ${ZOPEN_CHECK_OPTS}"
		fi
		export ZOPEN_CHECK_RESULTS_CMD="\"${ZOPEN_CHECK_RESULTS_CODE}\" \"${ZOPEN_LOG_DIR}\" \"${LOG_PFX}\""
	else
		unset ZOPEN_CHECK_CMD
		unset ZOPEN_CHECK_RESULTS_CMD
	fi

	if [ "${ZOPEN_INSTALL}x" != "skipx" ] && [ ! -z "$(command -v ${ZOPEN_INSTALL})" ]; then
		case "${ZOPEN_CONFIGURE}" in
		*cmake*)
			export ZOPEN_INSTALL_CMD="\"${ZOPEN_INSTALL}\" ${ZOPEN_INSTALL_OPTS}"
			;;
		*)
			export ZOPEN_INSTALL_CMD="\"${ZOPEN_INSTALL}\" ${ZOPEN_INSTALL_OPTS} $verboseOpts CC=${CC} \"CPPFLAGS=${CPPFLAGS}\" \"CFLAGS=${CFLAGS}\" CXX=${CXX} \"CXXFLAGS=${CXXFLAGS}\" \"LDFLAGS=${LDFLAGS}\""
			;;
		esac
		[[ -d ${ZOPEN_ROOT}/install ]] || mkdir -p ${ZOPEN_ROOT}/install
		paxFileName="${ZOPEN_ROOT}/install/${ZOPEN_NAME}.${LOG_PFX}.zos.pax.Z"
		export ZOPEN_PAX_CMD="pax -w -z -x pax \"-s#${ZOPEN_INSTALL_DIR}/#${ZOPEN_NAME}/#\" -f \"${paxFileName}\" \"${ZOPEN_INSTALL_DIR}/\""
	else
		unset ZOPEN_INSTALL_CMD
		unset ZOPEN_PAX_CMD
	fi

	if [ "${ZOPEN_CLEAN}x" != "skipx" ] && [ ! -z "$(command -v ${ZOPEN_CLEAN})" ]; then
		export ZOPEN_CLEAN_CMD="\"${ZOPEN_CLEAN}\" ${ZOPEN_CLEAN_OPTS}"
	else
		unset ZOPEN_CLEAN_CMD
	fi

	return 0
}

generateOCI() {
	if ! ${publishOCI}; then
		return 0
	fi
	printHeader "Generating OCI Image"
	package=$1
	name=$(echo $package | cut -d "-" -f 1)
	version=$(echo $package | cut -d "-" -f 2)

	# Make the version OCI compat
	case "$version" in
	*.*.*.*) ;;
	*.*.*) version="$version.0" ;;
	*.*) version="$version.0.0" ;;
	*) version="1.0.0.0" ;;
	esac

	dockerfilecontents="
FROM scratch

LABEL name=${name}
LABEL vendor=OSS
LABEL version=${version}
LABEL specification=1.0.0"

	cd ${ZOPEN_INSTALL_DIR}
	if [ -f "${ZOPEN_IMAGE_DOCKERFILE_NAME}" ]; then
		rm -f "${ZOPEN_IMAGE_DOCKERFILE_NAME}"
	fi
	printVerbose "Generating ${ZOPEN_IMAGE_DOCKERFILE_NAME}"
	for file in *; do
		dockerfilecontents="${dockerfilecontents}\nCOPY $file @{CONTAINER_READWRITE}/$file"
	done

	# Add required .env file
	mkdir -p .zpm
	cp .env .zpm/.env
	dockerfilecontents="${dockerfilecontents}\nCOPY .zpm @{CONTAINER_READWRITE}/.zpm"

	if ! asciiecho "$dockerfilecontents" "${ZOPEN_IMAGE_DOCKERFILE_NAME}"; then
		printError "Unable to make ${ZOPEN_IMAGE_DOCKERFILE_NAME}"
	fi

	if [ -z $ZOPEN_IMAGE_REGISTRY ]; then
		printWarning "Environment variable ZOPEN_IMAGE_REGISTRY is needed to push an OCI image"
		return 4
	fi
	if [ -z $ZOPEN_IMAGE_REGISTRY_ID ]; then
		printWarning "Environment variable ZOPEN_IMAGE_REGISTRY_ID is needed to push an OCI image"
		return 4
	fi
	if [ -z $ZOPEN_IMAGE_REGISTRY_KEY_FILE ] || [ ! -r $ZOPEN_IMAGE_REGISTRY_KEY_FILE ]; then
		printWarning "Environment variable ZOPEN_IMAGE_REGISTRY_KEY_FILE is needed to push an OCI image"
		return 4
	fi
	if [ -z "$(command -v ${ZOPEN_IMAGE_DOCKER_NAME})" ]; then
		printWarning "${ZOPEN_IMAGE_DOCKER_NAME} is not present on your system"
		return 4
	fi
	printVerbose "Generating OCI Image"
	"${ZOPEN_IMAGE_DOCKER_NAME}" build -t "${name}:${version}" .
	"${ZOPEN_IMAGE_DOCKER_NAME}" push "${name}:${version}" -i $ZOPEN_IMAGE_REGISTRY -u $ZOPEN_IMAGE_REGISTRY_ID -p @$ZOPEN_IMAGE_REGISTRY_KEY_FILE
	cd -
}

generateZOSLIBHooks() {
	# Background:
	#  As part of the build/install process, various tools may require application specific environment variables to be set.
	#  This function generates a C hook zoslib_env_hook() that will be called by ZOSLIB before main is entered.
	#  The function's purpose is to automatically set environment variables before main.
	#  Taking Git as an example, unless Git is installed in the standard location, (e.g. /usr/local/zopen),
	#  it has a requirement to set the following environment variables, GIT_TEMPLATE_DIR, GIT_EXEC_PATH, and
	#  GIT_SSL_CAINFO.
	#  This function takes input from zopen_append_to_zoslib_env. For Git, this looks like:
	# GIT_TEMPLATE_DIR|set|PROJECT_ROOT/share/git-core/templates
	# GIT_EXEC_PATH|set|PROJECT_ROOT/libexec/git-core
	# GIT_SSL_CAINFO|set|PROJECT_ROOT/cacert.pem
	#  The first field is the environment variable. The second field is the action, which is one of set, unset, or prepend.
	#  The last field is the value. For unset, this is left empty. PROJECT_ROOT is replaced by the root directory of where the project is installed to.

	zoslib_env=""
	#TODO: In the future, consider locating all shared libraries and adding the LIBPATH automatically
	#zoslib_env="PATH|prepend|PROJECT_ROOT/bin
	#LIBPATH|prepend|PROJECT_ROOT/lib
	#"

	if command -V "${ZOPEN_APPEND_TO_ZOSLIB_ENV_CODE}" >/dev/null 2>&1; then
		printVerbose "Appending additional environment zoslib variables..."
		zoslib_env="${zoslib_env}$(${ZOPEN_APPEND_TO_ZOSLIB_ENV_CODE})"
	else
		# Nothing to add, return
		return
	fi

	printHeader "Generating ZOSLIB Environment Hooks"

	# Generate directories
	mkdir -p .zoslib_hooks
	cd .zoslib_hooks

	output="zoslib_env_hook.c"

	# Defines zoslib_env_hook

	cat <<zz >$output
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define PROJECT_ROOT_STR "PROJECT_ROOT"

__attribute__((visibility("default"))) int zoslib_env_hook(char*) __attribute__((used));

__attribute__((visibility("default"))) int zoslib_env_hook(char* root_dir) {
char* envar_value;
char* value_str;
char* pos;
long size;

// Do not use when running under zopen
// To avoid test specific settings
if (getenv("ZOPEN_IN_ZOPEN_BUILD")) {
  return 0;
}
zz

	# Process input
	echo "$zoslib_env" | while read line; do
		if [ $(echo "$line" | awk -F '|' '{print NF-1}') -ne 2 ]; then
			printError "$line must have 2 '|' seperators only"
		fi
		var=$(echo $line | cut -d '|' -f 1)
		action=$(echo $line | cut -d '|' -f 2)
		value=$(echo $line | cut -d '|' -f 3)

		if [ "$action" = "unset" ]; then
			echo "unsetenv(\"$var\");" >>$output
		elif [ "$action" = "set" ]; then
			cat <<zz >>$output
    value_str = "$value";
    size = PATH_MAX;
    envar_value = (char*)malloc(size);
    memset(envar_value, 0, size);

    while (1) {
      pos = strstr(value_str, PROJECT_ROOT_STR);
      if (pos != NULL) {
        size_t length_before_project_root = pos - value_str;
        strncat(envar_value, value_str, length_before_project_root);
        strcat(envar_value, root_dir);
        value_str = pos + sizeof(PROJECT_ROOT_STR) - 1;
      } else {
        strcat(envar_value, value_str);
        break;
      }
    }

    if (!getenv("$var")) {
      if (getenv("__ZOPEN_DEBUG"))
        fprintf(stderr, "Setting variable %s=%s\n", "$var", envar_value);
      if (setenv("$var", envar_value, 1) != 0) {
        fprintf(stderr, "Error: Setting environment variable %s=%s\n", "$var", envar_value);
        exit(1);
      }
    }
    free(envar_value);
zz
		elif [ "$action" = "prepend" ]; then
			cat <<zz >>$output
    value_str = "$value";
    size = strlen(getenv("$var")) + strlen(value_str) + strlen(root_dir) + 2;
    envar_value = (char*)malloc(size);
    memset(envar_value, 0, size);

    // Substitute PROJECT_ROOT with root_dir (actual project directory)
    while (1) {
      pos = strstr(value_str, PROJECT_ROOT_STR);
      if (pos != NULL) {
        size_t length_before_project_root = pos - value_str;
        strncat(envar_value, value_str, length_before_project_root);
        strcat(envar_value, root_dir);
        value_str = pos + sizeof(PROJECT_ROOT_STR) - 1;
      } else {
        strcat(envar_value, value_str);
        break;
      }
    }

    strcat(envar_value, ":");
    strcat(envar_value, getenv("$var"));
    if (getenv("__ZOPEN_DEBUG"))
      fprintf(stderr, "Prepending variable %s=%s\n", "$var", envar_value);
    if (setenv("$var", envar_value, 1) != 0) {
      fprintf(stderr, "Error: prepending environment variable %s=%s\n", "$var", envar_value);
      exit(1);
    }
    free(envar_value);
zz
		else
			printError "$action is not valid, must be one of set, unset, or prepend"
		fi

	done

	echo "" >>$output
	echo "return 0;" >>$output
	echo "}" >>$output

	# xlclang pragma linkage does not work
	if [ "$CC" = "xlclang" ]; then
		extraOptions="-qexportall"
	fi
	if ! runAndLog "$CC $CFLAGS $CPPFLAGS -DPATH_MAX=1024 $extraOptions -c $output -o ${output}.o"; then
		printError "Compiler command for $output failed to compile"
	fi

	# Apply it in both LIB envars because some ports use ZOPEN_EXTRA_LIBS directly
	export ZOPEN_EXTRA_LIBS="${ZOPEN_EXTRA_LIBS} $PWD/${output}.o"
	export LIBS="${LIBS} $PWD/${output}.o"

	cd ..
}

#
# Start of 'main'
#

if ! setDefaults; then
	exit 4
fi

if ! processOptions $*; then
	exit 4
fi

export ZOPEN_ROOT=$(
	cd "$(dirname "$buildEnvFile")"
	pwd
)

if ! loadBuildEnv; then
	exit 4
fi

if ! checkEnv; then
	exit 4
fi

if ! setEnv; then
	exit 4
fi

if ! getCode; then
	exit 4
fi

if command -V "zopen_pre_patch" >/dev/null 2>&1; then
	printVerbose "Running zopen_pre_patch"
	"zopen_pre_patch" "${PWD}"
fi

if ! applyPatches; then
	exit 4
fi

if $getSourceOnly; then
	exit 0
fi

cd "${ZOPEN_ROOT}/${dir}" || exit 99

if [ "${ZOPEN_SRC_DIR}x" != "x" ]; then
	cd "${ZOPEN_SRC_DIR}" || exit 99
fi

generateZOSLIBHooks

if ! resolveCommands; then
	exit 4
fi

if command -V "${ZOPEN_INIT_CODE}" >/dev/null 2>&1; then
	printVerbose "Running ${ZOPEN_INIT_CODE}"
	"${ZOPEN_INIT_CODE}" "${PWD}"
fi

if ${startShell}; then
	if [ "${ZOPEN_SHELL}x" != "x" ]; then
		exec "${ZOPEN_SHELL}"
	else
		exec /bin/sh
	fi
fi

if $cleanupBuild || $forceRebuild || $freshBuild; then
	cleanup
	if $cleanupBuild; then
		exit 0
	fi
fi

if ! bootstrap; then
	exit 4
fi

if ! configure; then
	exit 4
fi

if ! build; then
	exit 4
fi

if ! check; then
	exit 4
fi

if ! install; then
	exit 4
fi

exit 0
